import argparse
import os
import sys # For sys.exit
import time
from moviepy.editor import VideoFileClip
import google.generativeai as genai

def convert_to_mp3(video_path):
    """Converts an MP4 video file to an MP3 audio file.

    Args:
        video_path (str): The path to the MP4 video file.

    Returns:
        str: The path to the created MP3 file, or None if conversion fails.
    """
    if not os.path.exists(video_path):
        print(f"Error: Video file not found at '{video_path}'. Please check the path and try again.")
        return None
    try:
        print(f"Starting MP4 to MP3 conversion for: {video_path}")
        video_clip = VideoFileClip(video_path)
        base, ext = os.path.splitext(video_path)
        mp3_file_path = base + ".mp3"
        
        # Suppress moviepy's own console output for a cleaner interface, if desired
        # video_clip.audio.write_audiofile(mp3_file_path, logger=None)
        video_clip.audio.write_audiofile(mp3_file_path)
        video_clip.close()
        print(f"Successfully converted '{video_path}' to '{mp3_file_path}'")
        return mp3_file_path
    except Exception as e:
        print(f"Error during MP4 to MP3 conversion for '{video_path}': {e}")
        print("Please ensure a valid video file (e.g., MP4) is provided and that ffmpeg is installed correctly if issues persist.")
        return None

def transcribe_audio_gemini(mp3_file_path, api_key):
    """Transcribes an MP3 audio file using the Gemini API.

    Args:
        mp3_file_path (str): The path to the MP3 audio file.
        api_key (str): The Gemini API key.

    Returns:
        str: The transcribed text, or None if transcription fails.
    """
    if not os.path.exists(mp3_file_path):
        print(f"Error: MP3 file not found at '{mp3_file_path}'. This file should have been generated by the script. Please check previous error messages.")
        return None
    
    audio_file_resource_name = None # To store the name for cleanup

    try:
        print("Configuring Gemini API...")
        genai.configure(api_key=api_key)

        print(f"Uploading audio file: '{mp3_file_path}' to Gemini. This may take a moment...")
        time.sleep(2) # Brief pause, as file might still be finalizing from conversion

        audio_file = genai.upload_file(path=mp3_file_path, display_name=os.path.basename(mp3_file_path))
        audio_file_resource_name = audio_file.name # Store for potential cleanup
        print(f"File uploaded successfully to Gemini: {audio_file.name} (URI: {audio_file.uri})")
        print(f"Current file state: {audio_file.state.name}")

        # Wait for the file to be active
        polling_interval = 10 # seconds
        max_wait_time = 300 # 5 minutes
        elapsed_wait_time = 0

        while audio_file.state.name == "PROCESSING":
            if elapsed_wait_time >= max_wait_time:
                print(f"Error: File '{audio_file.name}' processing timed out after {max_wait_time // 60} minutes.")
                return None # Cleanup will be attempted in finally block
            print(f"File is still processing. Waiting for {polling_interval} seconds...")
            time.sleep(polling_interval)
            elapsed_wait_time += polling_interval
            audio_file = genai.get_file(name=audio_file.name)
            print(f"Updated file state: {audio_file.state.name}")

        if audio_file.state.name == "FAILED":
            print(f"Error: File processing failed for '{audio_file.name}'. Reason: {audio_file.error}")
            return None # Cleanup will be attempted in finally block
        
        if audio_file.state.name != "ACTIVE":
            print(f"Error: File '{audio_file.name}' is not in ACTIVE state (current: {audio_file.state.name}). Transcription cannot proceed.")
            return None # Cleanup will be attempted in finally block

        print(f"File '{audio_file.name}' is active. Proceeding with transcription using 'gemini-1.5-flash'...")
        model = genai.GenerativeModel(model_name="models/gemini-1.5-flash")
        
        prompt = f"Transcribe the following audio file: '{os.path.basename(mp3_file_path)}'."
        response = model.generate_content([prompt, audio_file])

        if response and response.text:
            print("Transcription successful.")
            return response.text
        else:
            print("Transcription failed: The API returned no valid content or an empty response.")
            if response and response.prompt_feedback:
                 print(f"Prompt feedback from API: {response.prompt_feedback}")
            return None

    except FileNotFoundError: # Should be caught by the os.path.exists check earlier, but good as a safeguard
        print(f"Error: MP3 file not found at '{mp3_file_path}'. This should not happen at this stage.")
        return None
    except Exception as e:
        print(f"An unexpected error occurred during the Gemini API interaction: {e}")
        print("This could be due to an invalid API key, network issues, API quota limits, or an issue with the audio file.")
        print("Please check your API key, internet connection, and the Gemini API documentation for more details.")
        return None
    finally:
        # Clean up the uploaded file from Gemini, if it was uploaded
        if audio_file_resource_name:
            try:
                print(f"Attempting to delete uploaded file '{audio_file_resource_name}' from Gemini...")
                genai.delete_file(audio_file_resource_name)
                print(f"Successfully deleted file '{audio_file_resource_name}'.")
            except Exception as e_del:
                print(f"Warning: Could not delete uploaded file '{audio_file_resource_name}' from Gemini. Manual cleanup might be required. Error: {e_del}")


def main():
    parser = argparse.ArgumentParser(
        description="Converts an MP4 video file to MP3 audio and then transcribes the audio to text using the Gemini API.",
        epilog="Example: python video_to_text.py my_video.mp4 YOUR_GEMINI_API_KEY"
    )
    parser.add_argument(
        "video_path", 
        help="The full path to the MP4 video file you want to process."
    )
    parser.add_argument(
        "api_key", 
        help="Your Gemini API Key. Ensure it has the necessary permissions for file upload and content generation."
    )
    args = parser.parse_args()

    print(f"Processing video file: '{args.video_path}'")

    mp3_file_path = convert_to_mp3(args.video_path)

    if not mp3_file_path:
        print("MP3 conversion failed or was skipped. Cannot proceed with transcription.")
        sys.exit(1) # Exit with an error code

    print(f"MP3 file generated: '{mp3_file_path}'")
    
    # API key presence is already handled by argparse making it a required argument.
    # If it's missing, argparse exits before this point.
    
    print(f"Starting audio transcription for '{mp3_file_path}'...")
    transcript = transcribe_audio_gemini(mp3_file_path, args.api_key)

    if transcript:
        print("\n--- Transcription ---")
        print(transcript)
        print("--- End of Transcription ---")
        
        # Optionally, save transcript to a file
        transcript_filename = os.path.splitext(args.video_path)[0] + "_transcript.txt"
        try:
            with open(transcript_filename, "w") as f:
                f.write(transcript)
            print(f"\nTranscription also saved to: '{transcript_filename}'")
        except IOError as e:
            print(f"\nWarning: Could not save transcript to file '{transcript_filename}'. Error: {e}")
    else:
        print("Audio transcription failed or returned no content.")
        sys.exit(1) # Exit with an error code
    
    # Clean up the generated MP3 file (optional)
    try:
        print(f"Attempting to delete temporary MP3 file: '{mp3_file_path}'...")
        os.remove(mp3_file_path)
        print(f"Successfully deleted temporary MP3 file: '{mp3_file_path}'.")
    except OSError as e:
        print(f"Warning: Could not delete temporary MP3 file '{mp3_file_path}'. Error: {e}")


if __name__ == "__main__":
    main()
